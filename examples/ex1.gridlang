CALL @main
PUSH @end
GOTO

@factorial
# call equal
# ["n"]
PEEK << -1
PUSH 1
EQUAL
IFFGOTO @L0
PUSH 1
STORE retval
# ret, pop locals ["n"]
POP
PUSH retval
RETURN
# scope exit, pop ["1"]
POP
GOTO << @L1
@L0
@L1
# assign f
# call factorial
# call sub
# ["n"]
PEEK << -1
PUSH 1
SUB
CALL @factorial
# call mul
# ["n","f"]
PEEK << -2
# ["n","f","temp n"]
PEEK << -2
MUL
STORE retval
# ret, pop locals ["n","f"]
POP
POP
PUSH retval
RETURN
# scope exit, pop ["f","mul retval"]
POP
POP
# end @factorial

@fib
# call equal
# ["n"]
PEEK << -1
PUSH 0
EQUAL
IFFGOTO @L2
PUSH 0
STORE retval
# ret, pop locals ["n"]
POP
PUSH retval
RETURN
# scope exit, pop ["0"]
POP
GOTO << @L3
@L2
@L3
# call equal
# ["n"]
PEEK << -1
PUSH 1
EQUAL
IFFGOTO @L4
PUSH 1
STORE retval
# ret, pop locals ["n"]
POP
PUSH retval
RETURN
# scope exit, pop ["1"]
POP
GOTO << @L5
@L4
@L5
# assign f1
# call fib
# call sub
# ["n"]
PEEK << -1
PUSH 1
SUB
CALL @fib
# assign f2
# call fib
# call sub
# ["n","f1"]
PEEK << -2
PUSH 2
SUB
CALL @fib
# call add
# ["n","f1","f2"]
PEEK << -2
# ["n","f1","f2","temp f1"]
PEEK << -2
ADD
STORE retval
# ret, pop locals ["n","f1","f2"]
POP
POP
POP
PUSH retval
RETURN
# scope exit, pop ["f1","f2","add retval"]
POP
POP
POP
# end @fib

@assigntest
# call print
# ["a"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 20
PUSH -1
SWAP
POKE
# call print
# ["a"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
# assign k
PUSH 30
# call print
# ["a","k"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 40
PUSH -1
SWAP
POKE
# call print
# ["a","k"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 0
STORE retval
# ret, pop locals ["a","k"]
POP
POP
PUSH retval
RETURN
# scope exit, pop ["k","0"]
POP
POP
# end @assigntest

@scope
# assign a
PUSH 100
PUSH 1
IFFGOTO @L6
# assign b
PUSH 101
# call print
# ["a","b"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 102
PUSH -2
SWAP
POKE
# scope exit, pop ["b"]
POP
GOTO << @L7
@L6
@L7
# call print
# ["a"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 0
STORE retval
# ret, pop locals ["a"]
POP
PUSH retval
RETURN
# scope exit, pop ["a","0"]
POP
POP
# end @scope

@main
# call print
# call factorial
PUSH 4
CALL @factorial
PRINT
PUSH 0
# pop expr stm
POP
# call print
# call fib
PUSH 10
CALL @fib
PRINT
PUSH 0
# pop expr stm
POP
# call assigntest
PUSH 10
CALL @assigntest
# pop expr stm
POP
# call scope
CALL @scope
# pop expr stm
POP
# assign k
PUSH 0
# ["k"]
PEEK << -1
IFFGOTO @L8
# call print
PUSH 1
PRINT
PUSH 0
# pop expr stm
POP
GOTO << @L9
@L8
# call print
PUSH 2
PRINT
PUSH 0
# pop expr stm
POP
@L9
PUSH 1
IFFGOTO @L10
# call print
PUSH 1
PRINT
PUSH 0
# pop expr stm
POP
GOTO << @L11
@L10
# call print
PUSH 2
PRINT
PUSH 0
# pop expr stm
POP
@L11
PUSH 0
STORE retval
# ret, pop locals ["k"]
POP
PUSH retval
RETURN
# scope exit, pop ["k","0"]
POP
POP
# end @main

@end
END
