CALL << @main
END

@factorial
# call equal
# ["n"]
PEEK << -1
PUSH 0
EQUAL
IFFGOTO << @L0
PUSH 1
STORE retval
# ret, pop locals ["n"]
POPN << 1
PUSH retval
RETURN
# scope exit, pop ["1"]
POPN << 1
GOTO << @L1
@L0
# scope exit, pop []
POPN << 0
@L1
# assign f
# call factorial
# call sub
# ["n"]
PEEK << -1
PUSH 1
SUB
CALL << @factorial
# call mul
# ["n","f"]
PEEK << -2
# ["n","f","temp n"]
PEEK << -2
MUL
STORE retval
# ret, pop locals ["n","f"]
POPN << 2
PUSH retval
RETURN
# scope exit, pop ["f","mul retval"]
POPN << 2
# end @factorial

@fib
# call equal
# ["n"]
PEEK << -1
PUSH 0
EQUAL
IFFGOTO << @L2
PUSH 0
STORE retval
# ret, pop locals ["n"]
POPN << 1
PUSH retval
RETURN
# scope exit, pop ["0"]
POPN << 1
GOTO << @L3
@L2
# scope exit, pop []
POPN << 0
@L3
# call equal
# ["n"]
PEEK << -1
PUSH 1
EQUAL
IFFGOTO << @L4
PUSH 1
STORE retval
# ret, pop locals ["n"]
POPN << 1
PUSH retval
RETURN
# scope exit, pop ["1"]
POPN << 1
GOTO << @L5
@L4
# scope exit, pop []
POPN << 0
@L5
# call add
# call fib
# call sub
# ["n"]
PEEK << -1
PUSH 1
SUB
CALL << @fib
# call fib
# call sub
# ["n","fib retval"]
PEEK << -2
PUSH 2
SUB
CALL << @fib
ADD
STORE retval
# ret, pop locals ["n"]
POPN << 1
PUSH retval
RETURN
# scope exit, pop ["add retval"]
POPN << 1
# end @fib

@fib2
# assign a
PUSH 0
# assign b
PUSH 1
@L6
# ["n","a","b"]
PEEK << -3
IFFGOTO << @L7
# assign c
# ["n","a","b"]
PEEK << -2
# ["n","a","b","c"]
PEEK << -2
PUSH -3
SWAP
POKE
# call add
# ["n","a","b","c"]
PEEK << -2
# ["n","a","b","c","temp b"]
PEEK << -2
ADD
PUSH -2
SWAP
POKE
# call sub
# ["n","a","b","c"]
PEEK << -4
PUSH 1
SUB
PUSH -4
SWAP
POKE
# scope exit, pop ["c"]
POPN << 1
GOTO << @L6
PUSH @L6
@L7
# ["n","a","b"]
PEEK << -2
STORE retval
# ret, pop locals ["n","a","b"]
POPN << 3
PUSH retval
RETURN
# scope exit, pop ["a","b","temp a"]
POPN << 3
# end @fib2

@assigntest
# call print
# ["a"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 20
PUSH -1
SWAP
POKE
# call print
# ["a"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
# assign k
PUSH 30
# call print
# ["a","k"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 40
PUSH -1
SWAP
POKE
# call print
# ["a","k"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 0
STORE retval
# ret, pop locals ["a","k"]
POPN << 2
PUSH retval
RETURN
# scope exit, pop ["k","0"]
POPN << 2
# end @assigntest

@scope
# assign a
PUSH 100
PUSH 1
IFFGOTO << @L8
# assign b
PUSH 101
# call print
# ["a","b"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 102
PUSH -2
SWAP
POKE
# scope exit, pop ["b"]
POPN << 1
GOTO << @L9
@L8
# scope exit, pop []
POPN << 0
@L9
# call print
# ["a"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
PUSH 0
STORE retval
# ret, pop locals ["a"]
POPN << 1
PUSH retval
RETURN
# scope exit, pop ["a","0"]
POPN << 2
# end @scope

@nums
# assign a
PUSH 123
# assign b
PUSH -456
# assign c
PUSH 1.23
# assign d
PUSH -4.56
# call print
# ["a","b","c","d"]
PEEK << -4
PRINT
PUSH 0
# pop expr stm
POP
# call print
# ["a","b","c","d"]
PEEK << -3
PRINT
PUSH 0
# pop expr stm
POP
# call print
# ["a","b","c","d"]
PEEK << -2
PRINT
PUSH 0
# pop expr stm
POP
# call print
# ["a","b","c","d"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
# assign e
# call add
PUSH 1
# call add
# call mul
PUSH 2
PUSH 3
MUL
# call mul
PUSH 4
PUSH 5
MUL
ADD
ADD
# assign f
# call add
PUSH 1
# call add
# call mul
PUSH 2
PUSH 3
MUL
# call mul
PUSH 4
PUSH 5
MUL
ADD
ADD
# call print
# ["a","b","c","d","e","f"]
PEEK << -2
PRINT
PUSH 0
# pop expr stm
POP
# call print
# ["a","b","c","d","e","f"]
PEEK << -1
PRINT
PUSH 0
# pop expr stm
POP
# call print
# call mod
PUSH 5
PUSH 3
MOD
PRINT
PUSH 0
# pop expr stm
POP
PUSH 0
STORE retval
# ret, pop locals ["a","b","c","d","e","f"]
POPN << 6
PUSH retval
RETURN
# scope exit, pop ["a","b","c","d","e","f","0"]
POPN << 7
# end @nums

@main
# call print
# call factorial
PUSH 4
CALL << @factorial
PRINT
PUSH 0
# pop expr stm
POP
# call print
# call fib
PUSH 10
CALL << @fib
PRINT
PUSH 0
# pop expr stm
POP
# call print
# call fib2
PUSH 10
CALL << @fib2
PRINT
PUSH 0
# pop expr stm
POP
# call assigntest
PUSH 10
CALL << @assigntest
# pop expr stm
POP
# call scope
CALL << @scope
# pop expr stm
POP
# call nums
CALL << @nums
# pop expr stm
POP
PUSH 0
STORE retval
# ret, pop locals []
POPN << 0
PUSH retval
RETURN
# scope exit, pop ["0"]
POPN << 1
# end @main

